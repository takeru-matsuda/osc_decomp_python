import numpy as np
from typing import Optional
import sys
sys.path.append('../')
from pyoscdecomp.osc_decomp import osc_decomp

def my_randn(m: int, n: int, if_test: bool):
    """
    Customized randn function.
    Standard normal random numbers generated
    with the Box-Muller method are returned if if_test = True,
    otherwise random numbers generated by np.random.randn 
    are returned.
    Args:
        m: int, row number
        n: int, column number
        if_test: bool 
    Returns:
        Random ndarray of size (m, n).
    """    
    if (if_test):
        randns = np.empty((m, n))
        rands1 = np.random.rand(n, m).T
        rands2 = np.random.rand(n, m).T
        randns = (np.sqrt(- 2.0 * np.log(rands1)) 
                  * np.cos(2 * np.pi * rands2))
    else:
        randns = np.random.randn(m, n)

    return randns


def twin_uni(if_test: Optional[bool] = False, seed: Optional[int] = 5489):
    """
    Function implementing MATLAB script "twin_uni.m"    

    Args:
        if_test: bool. Defaults to False.
                Random numbers for testing is used if if_test = True.
        seed: int. Defaults to 5489.
                Used only when if_test = True.
    Returns:
        osc_AIC: ndarray, shape = (1, MAX_OSC)
            AIC of the oscillator model
        osc_mean: ndarray, shape = (2*MAX_OSC, T, MAX_OSC)
            smoothed coordinate of each oscillator
        osc_cov: ndarray, shape = (2*MAX_OSC, 2*MAX_OSC, T, MAX_OSC)
            smoothed covariance of each oscillator
        osc_phase:ndarray, shape = (MAX_OSC, T, MAX_OSC)
            estimated phase of each oscillation component
        minAIC: float
            min(AIC)
        K: int
            argmin(AIC) + 1
        osc_a: ndarray, shape = (1, K)
            estimated a_1,...,a_K
        osc_f: ndarray, shape = (1, K)
            estimated f_1,...,f_K
        osc_sigma2: ndarray, shape = (1, K)
            estimated sigma_1^2,...,sigma_K^2 
        osc_tau2: float
            estimated tau^2
    """    
    if (if_test):
        # generate same random number 
        # with MATLAB (use 'twister' in MATLAB)
        np.random.seed(seed) 

    T = 600
    K = 3
    fs = 200.0
    a = np.array([0.9, 0.9, 0.9])
    f = np.array([20, 50, 75])
    sigma2 = np.array([.1, .1, .1])
    tau2 = 0.1
    x = np.zeros((2*K, T))
    for k in range(K):
        x[2*k:2*k + 2, 0:1] = (
            np.sqrt(sigma2[k]) 
            / np.sqrt(1-a[k]**2)
            * my_randn(2, 1, if_test))

    for t in range(1, T):
        for k in range(K):
            x[2*k:2*k+2, t:t+1] = (
                a[k] * np.block(
                    [[np.cos(2*np.pi*f[k]/fs), -np.sin(2*np.pi*f[k]/fs)],
                     [np.sin(2*np.pi*f[k]/fs),  np.cos(2*np.pi*f[k]/fs)]])
                @ x[2*k:2*k+2, t-1:t] 
                + np.sqrt(sigma2[k]) * my_randn(2, 1, if_test))

    H = np.zeros((1, 2*K))
    H[0, np.arange(0, 2*K, 2)] = 1

    y = H @ x + np.sqrt(tau2) * my_randn(1, T, if_test)

    #print('y = ', y)

    MAX_OSC = 5
    [osc_param,
     osc_AIC,
     osc_mean,
     osc_cov,
     osc_phase] = osc_decomp(y, fs, MAX_OSC)

    minAIC = np.min(osc_AIC)
    osc_a = osc_param[K-1:K, 0:K]
    osc_f = osc_param[K-1:K, K:2*K]
    osc_sigma2 = osc_param[K-1:K, 2*K:3*K]
    osc_tau2 = osc_param[K-1:K, 3*K:3*K+1].item()

    return [osc_AIC, osc_mean, osc_cov, osc_phase,
            minAIC, K, osc_a, osc_f, osc_sigma2, osc_tau2]


if __name__ == '__main__':
    twin_uni()
