
import numpy as np
from typing import Optional
import os
import sys
parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(parent_dir)
from pyoscdecomp.osc_decomp import osc_decomp


def randn4test(m: int, n: int, if_test: bool):
    """
    Customized randn function for testing.
    Standard normal random numbers generated
    with the Box-Muller method are returned if if_test = True,
    otherwise random numbers generated by np.random.randn 
    are returned.
    Args:
        m: int, row number
        n: int, column number
        if_test: bool 
    Returns:
        Random ndarray of size (m, n).
    """    
    if (if_test):
        randns = np.empty((m, n))
        rands1 = np.random.rand(n, m).T
        rands2 = np.random.rand(n, m).T
        randns = (np.sqrt(- 2.0 * np.log(rands1)) 
                  * np.cos(2 * np.pi * rands2))
    else:
        randns = np.random.randn(m, n)

    return randns

def twin_multi(if_test: Optional[bool] = False, seed: Optional[int] = 5489):
    """
    Function implementing MATLAB script "twin_multi.m"    

    Args:
        if_test: bool. Defaults to False.
                Random numbers for testing is used if if_test = True.
        seed: int. Defaults to 5489.
                Used only when if_test = True.
    Returns:
        osc_AIC: ndarray, shape = (1, MAX_OSC)
            AIC of the oscillator model
        osc_mean: ndarray, shape = (2*MAX_OSC, T, MAX_OSC)
            smoothed coordinate of each oscillator
        osc_cov: ndarray, shape = (2*MAX_OSC, 2*MAX_OSC, T, MAX_OSC)
            smoothed covariance of each oscillator
        osc_phase:ndarray, shape = (MAX_OSC, T, MAX_OSC)
            estimated phase of each oscillation component
        minAIC: float
            min(AIC)
        K: int
            argmin(AIC) + 1
        osc_a: ndarray, shape = (1, K)
            estimated a_1,...,a_K
        osc_f: ndarray, shape = (1, K)
            estimated f_1,...,f_K
        osc_sigma2: ndarray, shape = (1, K)
            estimated sigma_1^2,...,sigma_K^2 
        osc_c: ndarray, shape = (1, (2*J-2)*K)
            estimated c_{21,1},c_{21,2},...,c_{J1,1},c_{J1,2},...,c_{JK,1},c_{JK,2}
        osc_tau2: float
            estimated tau^2
        Y: ndarray, shape = (J, T)
            generated input data
        fs: float
            sampling frequency
    """    
    if if_test:
        # generate same random number 
        # with MATLAB (use 'twister' in MATLAB)
        np.random.seed(seed)

    J = 2
    T = 200
    K = 3
    fs = 200
    a = np.array([0.9, 0.9, 0.9])
    f = np.array([20, 50, 75])
    sigma2 = np.array([.1, .1, .1])
    tau2 = 0.1
    x = np.zeros((2*K, T))
    for k in range(K):
        x[2*k:2*k + 2, 0:1] = (
            np.sqrt(sigma2[k]) 
            / np.sqrt(1-a[k]**2)
            * randn4test(2, 1, if_test))

    for t in range(1, T):
        for k in range(K):
            x[2*k:2*k+2, t:t+1] = (
                a[k] * np.block(
                    [[np.cos(2*np.pi*f[k]/fs), -np.sin(2*np.pi*f[k]/fs)],
                     [np.sin(2*np.pi*f[k]/fs),  np.cos(2*np.pi*f[k]/fs)]])
                @ x[2*k:2*k+2, t-1:t] 
                + np.sqrt(sigma2[k]) * randn4test(2, 1, if_test))

    H = np.zeros((J, 2*K))
    H[0, np.arange(0, 2*K, 2)] = 1
    H[1, :] = np.block([1.8, 1.2, 0, 1, -0.1, 0.4])
    Y = H @ x + np.sqrt(tau2) * randn4test(J, T, if_test)

    MAX_OSC = 5

    [
        osc_param,
        osc_AIC,
        osc_mean,
        osc_cov,
        osc_phase] = osc_decomp(
            Y, fs, MAX_OSC=MAX_OSC)

    minAIC = np.nanmin(osc_AIC)
    K = np.nanargmin(osc_AIC) + 1
    osc_a = osc_param[K-1:K, 0:K]
    osc_f = osc_param[K-1:K, K:2*K]
    osc_sigma2 = osc_param[K-1:K, 2*K:3*K]
    osc_c = osc_param[K-1:K, 3*K:(2*J+1)*K]
    osc_tau2 = osc_param[K-1, (2*J+1)*K]

    return [osc_AIC, osc_mean, osc_cov, osc_phase,
            minAIC, K, osc_a, osc_f, osc_sigma2, osc_c, osc_tau2,
            Y, fs]


if __name__ == '__main__':
    twin_multi()
